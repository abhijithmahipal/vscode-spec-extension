import * as vscode from "vscode";

export interface PromptOption {
  id: string;
  title: string;
  content: string;
  description: string;
  context?: string[];
}

export interface ClipboardResult {
  success: boolean;
  method: "clipboard" | "preview" | "file" | "cancelled";
  error?: string;
}

export class ClipboardManager {
  private static readonly MAX_PREVIEW_LENGTH = 200;
  private static readonly FALLBACK_FILE_NAME = "spec-prompt.md";

  /**
   * Enhanced clipboard operation with confirmation, preview, and fallback options
   * Addresses requirements 8.1, 8.3, 8.4, 8.5
   */
  static async copyPromptWithEnhancements(
    prompt: string,
    title: string = "Prompt",
    context?: string[]
  ): Promise<ClipboardResult> {
    try {
      // Requirement 8.4: Include all necessary context and instructions
      const enhancedPrompt = this.enhancePromptWithContext(prompt, context);

      // Requirement 8.5: For long prompts, provide options to view and edit
      if (enhancedPrompt.length > 1000) {
        return await this.handleLongPrompt(enhancedPrompt, title);
      }

      // Requirement 8.1: Show clear confirmation with preview
      const preview = this.createPromptPreview(enhancedPrompt);
      const action = await vscode.window.showInformationMessage(
        `Copy "${title}" to clipboard?`,
        {
          modal: false,
          detail: `Preview:\n${preview}\n\nLength: ${enhancedPrompt.length} characters`,
        },
        "Copy to Clipboard",
        "Preview Full Content",
        "Save to File",
        "Cancel"
      );

      switch (action) {
        case "Copy to Clipboard":
          return await this.performClipboardCopy(enhancedPrompt, title);

        case "Preview Full Content":
          return await this.showFullPreview(enhancedPrompt, title);

        case "Save to File":
          return await this.savePromptToFile(enhancedPrompt, title);

        case "Cancel":
        default:
          return { success: false, method: "cancelled" };
      }
    } catch (error) {
      // Requirement 8.3: Provide fallback options when clipboard operations fail
      return await this.handleClipboardFailure(prompt, title, error);
    }
  }

  /**
   * Handle multiple prompt options
   * Addresses requirement 8.2
   */
  static async copyFromMultiplePrompts(
    prompts: PromptOption[]
  ): Promise<ClipboardResult> {
    if (prompts.length === 0) {
      vscode.window.showWarningMessage("No prompts available to copy.");
      return { success: false, method: "cancelled" };
    }

    if (prompts.length === 1) {
      return await this.copyPromptWithEnhancements(
        prompts[0].content,
        prompts[0].title,
        prompts[0].context
      );
    }

    // Show quick pick for multiple prompts
    const items = prompts.map((prompt) => ({
      label: prompt.title,
      description: prompt.description,
      detail: this.createPromptPreview(prompt.content),
      prompt: prompt,
    }));

    const selected = await vscode.window.showQuickPick(items, {
      placeHolder: "Select a prompt to copy",
      matchOnDescription: true,
      matchOnDetail: true,
    });

    if (!selected) {
      return { success: false, method: "cancelled" };
    }

    return await this.copyPromptWithEnhancements(
      selected.prompt.content,
      selected.prompt.title,
      selected.prompt.context
    );
  }

  /**
   * Enhance prompt with context and instructions
   * Addresses requirement 8.4
   */
  private static enhancePromptWithContext(
    prompt: string,
    context?: string[]
  ): string {
    const timestamp = new Date().toISOString();
    let enhancedPrompt = `# Spec-Driven Development Prompt
Generated: ${timestamp}

`;

    if (context && context.length > 0) {
      enhancedPrompt += `## Context Files
Please read and consider the following files for context:
${context.map((file) => `- ${file}`).join("\n")}

`;
    }

    enhancedPrompt += `## Instructions
${prompt}

---
Generated by VSCode Spec-Driven Development Extension`;

    return enhancedPrompt;
  }

  /**
   * Create a preview of the prompt content
   */
  private static createPromptPreview(prompt: string): string {
    if (prompt.length <= this.MAX_PREVIEW_LENGTH) {
      return prompt;
    }

    const preview = prompt.substring(0, this.MAX_PREVIEW_LENGTH);
    const lastSpace = preview.lastIndexOf(" ");
    const truncated =
      lastSpace > this.MAX_PREVIEW_LENGTH * 0.8
        ? preview.substring(0, lastSpace)
        : preview;

    return `${truncated}...`;
  }

  /**
   * Handle long prompts with view and edit options
   * Addresses requirement 8.5
   */
  private static async handleLongPrompt(
    prompt: string,
    title: string
  ): Promise<ClipboardResult> {
    const action = await vscode.window.showWarningMessage(
      `"${title}" is quite long (${prompt.length} characters). How would you like to proceed?`,
      {
        modal: true,
        detail:
          "Long prompts might be truncated in some contexts. Consider reviewing before copying.",
      },
      "View & Edit",
      "Copy Anyway",
      "Save to File",
      "Cancel"
    );

    switch (action) {
      case "View & Edit":
        return await this.openPromptForEditing(prompt, title);

      case "Copy Anyway":
        return await this.performClipboardCopy(prompt, title);

      case "Save to File":
        return await this.savePromptToFile(prompt, title);

      case "Cancel":
      default:
        return { success: false, method: "cancelled" };
    }
  }

  /**
   * Perform the actual clipboard copy operation
   */
  private static async performClipboardCopy(
    prompt: string,
    title: string
  ): Promise<ClipboardResult> {
    try {
      await vscode.env.clipboard.writeText(prompt);

      // Show success notification with next steps
      const action = await vscode.window.showInformationMessage(
        `✅ "${title}" copied to clipboard successfully!`,
        "Open Copilot Chat",
        "Dismiss"
      );

      if (action === "Open Copilot Chat") {
        await vscode.commands.executeCommand(
          "workbench.panel.chat.view.copilot.focus"
        );
        await vscode.commands.executeCommand("workbench.action.chat.newChat");
      }

      return { success: true, method: "clipboard" };
    } catch (error) {
      throw error; // Let the caller handle the fallback
    }
  }

  /**
   * Show full preview in a new document
   */
  private static async showFullPreview(
    prompt: string,
    title: string
  ): Promise<ClipboardResult> {
    try {
      const doc = await vscode.workspace.openTextDocument({
        content: prompt,
        language: "markdown",
      });

      await vscode.window.showTextDocument(doc, {
        preview: true,
        viewColumn: vscode.ViewColumn.Beside,
      });

      // Ask if they want to copy after viewing
      const action = await vscode.window.showInformationMessage(
        `Preview of "${title}" opened. Copy to clipboard?`,
        "Copy to Clipboard",
        "Save to File",
        "Close"
      );

      switch (action) {
        case "Copy to Clipboard":
          return await this.performClipboardCopy(prompt, title);
        case "Save to File":
          return await this.savePromptToFile(prompt, title);
        default:
          return { success: true, method: "preview" };
      }
    } catch (error) {
      vscode.window.showErrorMessage(
        `Failed to show preview: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
      return { success: false, method: "preview", error: String(error) };
    }
  }

  /**
   * Open prompt in editor for viewing and editing
   */
  private static async openPromptForEditing(
    prompt: string,
    title: string
  ): Promise<ClipboardResult> {
    try {
      const doc = await vscode.workspace.openTextDocument({
        content: prompt,
        language: "markdown",
      });

      const editor = await vscode.window.showTextDocument(doc, {
        preview: false,
        viewColumn: vscode.ViewColumn.Active,
      });

      // Show information about editing
      const action = await vscode.window.showInformationMessage(
        `"${title}" opened for editing. Make your changes and then choose an action.`,
        "Copy Current Content",
        "Save to File",
        "Close"
      );

      const currentContent = editor.document.getText();

      switch (action) {
        case "Copy Current Content":
          return await this.performClipboardCopy(currentContent, title);
        case "Save to File":
          return await this.savePromptToFile(currentContent, title);
        default:
          return { success: true, method: "preview" };
      }
    } catch (error) {
      vscode.window.showErrorMessage(
        `Failed to open for editing: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
      return { success: false, method: "preview", error: String(error) };
    }
  }

  /**
   * Save prompt to file as fallback option
   */
  private static async savePromptToFile(
    prompt: string,
    title: string
  ): Promise<ClipboardResult> {
    try {
      const workspaceRoot = vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
      if (!workspaceRoot) {
        throw new Error("No workspace folder available");
      }

      const fileName = `${title
        .toLowerCase()
        .replace(/[^a-z0-9]/g, "-")}-prompt.md`;
      const uri = vscode.Uri.file(`${workspaceRoot}/${fileName}`);

      await vscode.workspace.fs.writeFile(uri, Buffer.from(prompt, "utf8"));

      const action = await vscode.window.showInformationMessage(
        `✅ "${title}" saved to ${fileName}`,
        "Open File",
        "Copy File Content",
        "Dismiss"
      );

      if (action === "Open File") {
        await vscode.window.showTextDocument(uri);
      } else if (action === "Copy File Content") {
        return await this.performClipboardCopy(prompt, title);
      }

      return { success: true, method: "file" };
    } catch (error) {
      vscode.window.showErrorMessage(
        `Failed to save to file: ${
          error instanceof Error ? error.message : "Unknown error"
        }`
      );
      return { success: false, method: "file", error: String(error) };
    }
  }

  /**
   * Handle clipboard operation failures with fallback options
   * Addresses requirement 8.3
   */
  private static async handleClipboardFailure(
    prompt: string,
    title: string,
    error: any
  ): Promise<ClipboardResult> {
    const errorMessage = error instanceof Error ? error.message : String(error);

    const action = await vscode.window.showErrorMessage(
      `Failed to copy "${title}" to clipboard: ${errorMessage}`,
      "Save to File",
      "Show in Preview",
      "Try Again",
      "Cancel"
    );

    switch (action) {
      case "Save to File":
        return await this.savePromptToFile(prompt, title);

      case "Show in Preview":
        return await this.showFullPreview(prompt, title);

      case "Try Again":
        try {
          await vscode.env.clipboard.writeText(prompt);
          vscode.window.showInformationMessage(
            `✅ "${title}" copied successfully on retry!`
          );
          return { success: true, method: "clipboard" };
        } catch (retryError) {
          return {
            success: false,
            method: "clipboard",
            error: String(retryError),
          };
        }

      case "Cancel":
      default:
        return { success: false, method: "cancelled", error: errorMessage };
    }
  }

  /**
   * Utility method to create prompt options for different contexts
   */
  static createPromptOption(
    id: string,
    title: string,
    content: string,
    description: string,
    context?: string[]
  ): PromptOption {
    return {
      id,
      title,
      content,
      description,
      context,
    };
  }
}
